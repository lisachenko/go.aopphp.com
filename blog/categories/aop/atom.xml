<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: aop | Go! Aspect-Oriented Framework]]></title>
  <link href="http://go.aopphp.com/blog/categories/aop/atom.xml" rel="self"/>
  <link href="http://go.aopphp.com/"/>
  <updated>2013-07-11T22:26:21+04:00</updated>
  <id>http://go.aopphp.com/</id>
  <author>
    <name><![CDATA[Lisachenko Alexander]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Application-level logging with AOP and Monolog]]></title>
    <link href="http://go.aopphp.com/blog/2013/06/02/application-level-logging-with-aop-and-monolog/"/>
    <updated>2013-06-02T13:50:00+04:00</updated>
    <id>http://go.aopphp.com/blog/2013/06/02/application-level-logging-with-aop-and-monolog</id>
    <content type="html"><![CDATA[<p>So you got finished with your brand new website. It is completely PHP driven and looks very nice. But are you sure that
everything works perfectly? Under every circumstances?</p>

<p>No. You can never be absolutely sure. That is why you need a log file to see if there where some errors. Well, if you
are the kind of person that doesn’t care if some jerks who behaved wrong on you website get error messages, then you
probably don’t need an error log file.</p>

<!-- more -->


<p>If you decide to to write the logs, then you definitely choose the best tool for this &ndash; <a href="https://github.com/Seldaek/monolog">Monolog</a>.
Monolog is used by such frameworks as Symfony2, Silex, Laravel4, PPI and can be easily integrated into custom application.</p>

<p>But even such a great tool like Monolog can not help us with encapsulating the logging into separate class, because
logging is a <a href="http://en.wikipedia.org/wiki/Cross-cutting_concern">cross-cutting concern</a>. This means that logging do not
fit cleanly into object-oriented programming. As a result, the code addressing the logging must be scattered, or duplicated,
across the various related locations, resulting in a loss of modularity.</p>

<p>Aspect-oriented programming aims to encapsulate cross-cutting concerns into aspects to retain modularity.
This allows for the clean isolation and reuse of code addressing the cross-cutting concern. By basing designs on
cross-cutting concerns, software engineering benefits are effected, including modularity and simplified maintenance.
This article will show you how to combine the power of AOP with the ease of use of Monolog to implement application-level
 logging just in few lines.</p>

<h3>Installation</h3>

<p>First of all, we need to install Monolog (if it isn&rsquo;t available). Monolog is available on Packagist (monolog/monolog)
and as such installable via Composer:</p>

<p><code>bash
$ composer require monolog/monolog
</code></p>

<p>If you do not use Composer, you can grab the code of Monolog from GitHub, and use any PSR-0 compatible autoloader
(e.g. the Symfony2 ClassLoader component) to load Monolog classes.</p>

<p>Next tool that we need is <a href="http://go.aopphp.com">Go! Aspect-Oriented Framework</a>. You can find more information about installation
and configuration in the <a href="/docs/">documentation</a> section.</p>

<p>If you use a Composer, then installation is quite easy:</p>

<p><code>bash
$ composer require lisachenko/go-aop-php
</code></p>

<p>Small configuration is required to prepare the AOP kernel for work. Detailed instructions are
available <a href="/docs/initial-configuration/">here</a>. After installation and configuration we are ready for the dark power of
AOP</p>

<h3>Implementing logging aspect</h3>

<p>So, what is aspect?</p>

<p><blockquote><p>In computer science, an aspect of a program is a feature linked to many other parts of the program, but which is not related to the program&rsquo;s primary function.</p></blockquote></p>

<p>Go! framework defines an aspect as a typical class with methods-advices. Each advice contains a specific logic that can be
invoked before, after or around specific part of code in your application. Let&rsquo;s try to describe an advice for logging.</p>

<p>Suppose, that we want to log an execution of methods. We want to write a method name and an arguments before execution of a method.
Typically this is looking like this:</p>

<p>```php
&lt;?php
class Example
{</p>

<pre><code>/**
 * Instance of logger (injected in constructor or by setter)
 */
protected $logger;
</code></pre>

<p>    public function test($arg1, $arg2)</p>

<pre><code>{
    $this-&gt;logger-&gt;info("Executing " . __METHOD__, func_get_args());
    // ... logic of method here
}

public function anotherTest($arg1)
{
    $this-&gt;logger-&gt;info("Executing " . __METHOD__, func_get_args());
    // ... logic of method here
}
</code></pre>

<p>}
```</p>

<p>We can notice that the code addressing the logging is scattered and duplicated. To solve this issue we can extract this code into the separate &ldquo;before&rdquo; advice:</p>

<p>```php
&lt;?php
use Go\Aop\Aspect;</p>

<p>class LoggingAspect implements Aspect
{</p>

<pre><code>/**
 * Instance of logger (injected in constructor or by setter)
 */
protected $logger;

public function beforeMethodExecution()
{
    $this-&gt;logger-&gt;info("Executing " . __METHOD__, func_get_args());
    // return the control to original code
}
</code></pre>

<p>}
```</p>

<p>Ok, we have extracted the advice itself, but how we get a method name and arguments? Go! framework contains a specific class, that implements <code>MethodInvocation</code> interface. This interface gives an information about joinpoint by providing an access to the reflection object. Each advice is receiving an instance of this class as an argument:</p>

<p>```php
&lt;?php
use Go\Aop\Aspect;
use Go\Aop\Intercept\MethodInvocation;</p>

<p>class LoggingAspect implements Aspect
{</p>

<pre><code>/**
 * Instance of logger (injected in constructor or by setter)
 */
protected $logger;

public function beforeMethodExecution(MethodInvocation $invocation)
{
    $this-&gt;logger-&gt;info("Executing " . $invocation-&gt;getMethod()-&gt;name, $invocation-&gt;getArguments());
}
</code></pre>

<p>}
```
There is one more question to solve: &ldquo;how to specify concrete methods?&rdquo;. This is known as a pointcut &ndash; the term given to the point of execution in the application at which cross-cutting concern needs to be applied.</p>

<p>Go! framework uses annotations for defining pointcuts. Pointcut syntax is like an SQL for the source code. To intercept each public and protected method in the class we can use &ldquo;within&rdquo; pointcut:</p>

<p>```php
&lt;?php
use Go\Aop\Aspect;
use Go\Aop\Intercept\MethodInvocation;
use Go\Lang\Annotation\After;
use Go\Lang\Annotation\Before;
use Go\Lang\Annotation\Around;</p>

<p>class LoggingAspect implements Aspect
{</p>

<pre><code>/**
 * Instance of logger (injected in constructor or by setter)
 */
protected $logger;

/**
 * @Before("within(**)")
 */
public function beforeMethodExecution(MethodInvocation $invocation)
{
    $this-&gt;logger-&gt;info("Executing " . $invocation-&gt;getMethod()-&gt;name, $invocation-&gt;getArguments());
}
</code></pre>

<p>}
```</p>

<p>Pointcut syntax allows many constructions, for example: &ldquo;within(My\Super\Class)&rdquo;, &ldquo;execution(public ClassName-><em>(</em>))&rdquo;, &ldquo;@annotation(Annotation\Class\Name)&rdquo; and more. You can play with pointcuts to look at result )</p>

<p>To register the aspect just add an instance of it in the <code>configureAop()</code> method of the kernel:</p>

<p>```php
&lt;?php
// app/ApplicationAspectKernel.php</p>

<p>use LoggingAspect;</p>

<p>//&hellip;</p>

<pre><code>protected function configureAop(AspectContainer $container)
{
    $container-&gt;registerAspect(new LoggingAspect());
}
</code></pre>

<p>//&hellip;
```</p>

<p>If you don&rsquo;t know how to inject a logger, you can try to initialize it in the aspect constructor:</p>

<p>```php
&lt;?php
use Go\Aop\Aspect;
use Go\Aop\Intercept\MethodInvocation;
use Go\Lang\Annotation\After;
use Go\Lang\Annotation\Before;
use Go\Lang\Annotation\Around;</p>

<p>use Monolog;</p>

<p>/<em>*
 * Logging aspect
 </em>/
class LoggingAspect implements Aspect
{</p>

<pre><code>protected $logger;

public function __construct()
{
    $this-&gt;logger = new Monolog\Logger('test');
    $this-&gt;logger-&gt;pushHandler(new Monolog\Handler\StreamHandler('php://output'));
}

/**
 * @Before("within(**)")
 */
public function beforeMethodExecution(MethodInvocation $invocation)
{
    $obj   = $invocation-&gt;getThis();
    $class = $obj === (object)$obj ? get_class($obj) : $obj;
    $this-&gt;logger-&gt;info("Executing " . $class.'-&gt;'.$invocation-&gt;getMethod()-&gt;name, $invocation-&gt;getArguments());
}
</code></pre>

<p>}
```</p>

<p>If you run an application you can get an output like this (example for a Go! <a href="https://github.com/lisachenko/go-aop-php/blob/master/demos/life.php">demo</a>):
<code>
Want to eat something, let's have a breakfast!&lt;br&gt;
[2013-06-02 11:50:14] test.INFO: Executing Example\Human-&gt;eat [] []
[2013-06-02 11:50:14] test.INFO: Executing Example\Human-&gt;washUp [] []
Washing up...&lt;br&gt;
Eating...&lt;br&gt;
[2013-06-02 11:50:14] test.INFO: Executing Example\Human-&gt;cleanTeeth [] []
Cleaning teeth...&lt;br&gt;
I should work to earn some money&lt;br&gt;
[2013-06-02 11:50:14] test.INFO: Executing Example\Human-&gt;work [] []
Working...&lt;br&gt;
It was a nice day, go to bed&lt;br&gt;
[2013-06-02 11:50:14] test.INFO: Executing Example\Human-&gt;cleanTeeth [] []
Cleaning teeth...&lt;br&gt;
[2013-06-02 11:50:14] test.INFO: Executing Example\Human-&gt;sleep [] []
Go to sleep...&lt;br&gt;
[2013-06-02 11:50:14] test.INFO: Executing Example\User-&gt;setName ["test"] []
[2013-06-02 11:50:14] test.INFO: Executing Example\User-&gt;setSurname ["a"] []
[2013-06-02 11:50:14] test.INFO: Executing Example\User-&gt;setPassword ["root"] []
</code></p>

<p>So, we have implemented logging without changes in the original source code! Have a nice experiments!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Implementing reusable fluent interface pattern in PHP with AOP]]></title>
    <link href="http://go.aopphp.com/blog/2013/03/19/implementing-fluent-interface-pattern-in-php/"/>
    <updated>2013-03-19T22:44:00+04:00</updated>
    <id>http://go.aopphp.com/blog/2013/03/19/implementing-fluent-interface-pattern-in-php</id>
    <content type="html"><![CDATA[<p>During software development one of the most important goals is the readability of source code. There are special
techniques and tips that help us to improve the readability of source code. One of the techniques of improving the
source code readability is using of fluent interfaces. Let&rsquo;s discuss it in this article.</p>

<!-- more -->


<h3>Evolution. From simple to complex.</h3>

<p>Every programmer starts with the language by writing a trivial &ldquo;Hello, world!&rdquo;. After that, it takes several years to
learn the language and to make clumsy attempts to write his own ORM / CMS / Framework (underline one or several). I
think that everyone has the code which is better to hide. But without understanding of simple things you will not be
able to understand the complex ones, so let&rsquo;s start with a simple example and get to the implementation of the &ldquo;fluent&rdquo;
interface as a separate class using AOP. Those who know this pattern can safely move on to the last part of the article,
where you can get excellent food for thoughts.</p>

<p>Let&rsquo;s start!</p>

<p>Let&rsquo;s take a simple user entity, which has the following properties: name, last name and the password:</p>

<p><code>php
&lt;?php
class User
{
    public $name;
    public $surname;
    public $password;
}
</code>
An excellent class that is easy to use:
```php
&lt;?php
$user = new User;</p>

<p>$user->name = &lsquo;John&rsquo;;
$user->surname = &lsquo;Doe&rsquo;;
$user->password = &lsquo;root&rsquo;;
```</p>

<p>It is easy to notice that we have no validation and somebody can set a blank password, which is not very good. In
addition, it would be nice to know that the field values are immutable. These several considerations lead us to the
idea that properties should be protected or private and access to them should be carried out with a pair of getter / setter.</p>

<p>Suit the action to the word:
```php
&lt;?php
class User
{</p>

<pre><code>protected $name;
protected $surname;
protected $password;

public function setName($name)
{
    $this-&gt;name = $name;
}

public function setSurname($surname)
{
    $this-&gt;surname = $surname;
}

public function setPassword($password)
{
    if (!$password) {
        throw new InvalidArgumentException("Password shouldn't be empty");
    }
    $this-&gt;password = $password;
}
</code></pre>

<p>}
<code>
For the new class the configuration has changed a little and now we are using setters:
</code>php
&lt;?php
$user = new User;</p>

<p>$user->setName(&lsquo;John&rsquo;);
$user->setSurname(&lsquo;Doe&rsquo;);
$user->setPassword(&lsquo;root&rsquo;);
```</p>

<p>Not a big deal, right? But what if we need to set up 20 properties? 30 properties? This code will be flooded with setter
calls and $user variable references. If the variable name will be $superImportantUser then readability of the source
code deteriorates further. What can be done to get rid of the copy of the code?</p>

<h3>Fluent interface to the rescue!</h3>

<p>So, we came to the Fluent Interface pattern, which was coined by Eric Evans and Martin Fowler to increase readability of
source code by simplifying multiple calls to the same object. It is implemented by a chain of methods, transmitting the
calling context to the following method in the chain. The context is the return value of the method and this value can
be any object, including the current one.</p>

<p>To implement a fluent interface, we need all the methods-setters to return the current object:
```php
&lt;?php
class User
{</p>

<pre><code>protected $name;
protected $surname;
protected $password;

public function setName($name)
{
    $this-&gt;name = $name;
    return $this;
}

public function setSurname($surname)
{
    $this-&gt;surname = $surname;
    return $this;
}

public function setPassword($password)
{
    if (!$password) {
        throw new InvalidArgumentException("Password shouldn't be empty");
    }
    $this-&gt;password = $password;
    return $this;
}
</code></pre>

<p>}
```
This approach will allow us to make the call chain:</p>

<p><code>php
&lt;?php
$user = new User;
$user-&gt;setName('John')-&gt;setSurname('Doe')-&gt;setPassword('root');
</code></p>

<p>As you can see, the configuration of the object now takes up less space and is much easier to read. We achieved our
goal! At this point, many developers will ask: &ldquo;So what?&rdquo; Ok, then try to answer the question: &ldquo;What&rsquo;s wrong with fluent
interface in this way?&rdquo; before reading the next section.</p>

<h3>So what&rsquo;s bad in it?</h3>

<p>Perhaps you&rsquo;ve failed to find an answer and you&rsquo;ve decided to read further? ) Well, I can reassure you that it&rsquo;s all
fine with fluent interface in OOP. However, if you think about it, you can find out that it can&rsquo;t be implemented as a
separate class, interface or trait. So it can&rsquo;t be reused. This results in the fact that we have to put down &ldquo;return
$this&rdquo; at the end of each method to implement fluent interface. If we have a couple dozen classes with a couple dozen
methods that we want to do &ldquo;fluent&rdquo; then we have to manually deal with this unpleasant operation.
This is the classic crosscutting.</p>

<h3>Let&rsquo;s make it in a separate class</h3>

<p>Since we have a crosscutting, we must rise to the level above OOP to describe this pattern. Specification is pretty
simple: when calling public methods in a class, original object should be returned as the result of the method
invocation. Of course, we do not want unexpected effects, so let&rsquo;s be clear: methods should be public setters starting
with &ldquo;set&rdquo; and they should be inside classes that implement FluentInterface marker only . Let&rsquo;s describe this with AOP
and Go! AOP library.</p>

<p>First of all, our marker interface:</p>

<p>```php
&lt;?php
/<em>*
 * Fluent interface marker
 </em>/
interface FluentInterface
{</p>

<p>}
```
Fluent interface implementation in the form of advice within aspect:</p>

<p>```php
&lt;?php
use Go\Aop\Aspect;
use Go\Aop\Intercept\MethodInvocation;
use Go\Lang\Annotation\Around;</p>

<p>class FluentInterfaceAspect implements Aspect
{</p>

<pre><code>/**
 * Fluent interface advice
 *
 * @Around("within(FluentInterface+) &amp;&amp; execution(public **-&gt;set*(*))")
 *
 * @param MethodInvocation $invocation
 * @return mixed|null|object
 */
protected function aroundMethodExecution(MethodInvocation $invocation)
{
    $result = $invocation-&gt;proceed();
    return $result!==null ? $result : $invocation-&gt;getThis();
}
</code></pre>

<p>}
```</p>

<p>Just a quick explanation &ndash; &ldquo;Around&rdquo; advice sets the hook &ldquo;around&rdquo; the original method and is fully responsible for
whether the original method will be called or not, and is responsible for the result that will be returned. In the
advice, we call original method (setter invocation) and if it doesn&rsquo;t return anything we just return the original
object $invocation->getThis(). That is all ) That is a useful pattern implementation just in a few lines of code. Using
the fluent interface is now easy and sexy :)</p>

<p>```php
&lt;?php
class User implements FluentInterface
{</p>

<pre><code>protected $name;
protected $surname;
protected $password;

public function setName($name)
{
    $this-&gt;name = $name;
}

public function setSurname($surname)
{
    $this-&gt;surname = $surname;
}

public function setPassword($password)
{
    if (!$password) {
        throw new InvalidArgumentException("Password shouldn't be empty");
    }
    $this-&gt;password = $password;
}
</code></pre>

<p>}
```
And usage:</p>

<p><code>php
&lt;?php
$user = new User;
$user-&gt;setName('John')-&gt;setSurname('Doe')-&gt;setPassword('root');
</code>
No more copying &ldquo;return $this&rdquo; for hundreds of methods, only pure source code, intuitive FluentInterface and
implementation of FluentInterface in the form of a simple aspect.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Aspect-Oriented Framework for PHP]]></title>
    <link href="http://go.aopphp.com/blog/2013/02/11/aspect-oriented-framework-for-php/"/>
    <updated>2013-02-11T22:55:00+04:00</updated>
    <id>http://go.aopphp.com/blog/2013/02/11/aspect-oriented-framework-for-php</id>
    <content type="html"><![CDATA[<p>Go! is a PHP 5.4 framework based on OOP and AOP paradigms and designed by Lisachenko Alexander.
It allows developers to add support of AOP to every PHP application.</p>

<p>Go! doesn&rsquo;t require any PECL-extentions, it neither uses any dark magic of Runkit nor evals, the library doesn&rsquo;t use DI-containers.
The code with weaved aspects is fully readable and native, it can be easily debugged with XDebug.
You can debug either classes or aspects.
The main advantage of Go! is that potentially it can be installed in every PHP-application,
because you don&rsquo;t have to change the application source code at all.
As an example, with the help of 10-20 lines of code we can intercept all the public, protected and static methods in all the classes
of application and display the name and the arguments of each method during its execution.</p>

<h2>What is AOP?</h2>

<p><a href="http://en.wikipedia.org/wiki/Aspect-oriented_programming">AOP (Aspect-Oriented Programming)</a> is an approach to cross-cutting concerns, where the concerns are designed and implemented
in a &ldquo;modular&rdquo; way (that is, with appropriate encapsulation, lack of duplication, etc.), then integrated into all the relevant
execution points in a succinct and robust way, e.g. through declarative or programmatic means.</p>

<p>In AOP terms, the execution points are called join points, a particular set of them is called a pointcut and the new
behavior that is executed before, after, or &ldquo;around&rdquo; a join point is called advice. You can read more about AOP in
<a href="/docs/introduction/">Introduction</a> section.</p>

<p>PHP traits can be used to implement some aspect-like functionality.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SymfonyCampUA-2012 presentation]]></title>
    <link href="http://go.aopphp.com/blog/2012/12/02/symfonycampua-2012-presentation-about-weaving-of-aspects-with-go-aop-library/"/>
    <updated>2012-12-02T00:00:00+04:00</updated>
    <id>http://go.aopphp.com/blog/2012/12/02/symfonycampua-2012-presentation-about-weaving-of-aspects-with-go-aop-library</id>
    <content type="html"><![CDATA[<iframe src="http://www.slideshare.net/slideshow/embed_code/15487433?rel=0" width="597" height="486" frameborder="0" marginwidth="0" marginheight="0" scrolling="no" style="border:1px solid #CCC;border-width:1px 1px 0;margin-bottom:5px" allowfullscreen webkitallowfullscreen mozallowfullscreen>
</iframe>

]]></content>
  </entry>
  
</feed>
