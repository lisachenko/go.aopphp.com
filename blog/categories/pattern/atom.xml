<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: pattern | Go! Aspect-Oriented Framework]]></title>
  <link href="http://go.aopphp.com/blog/categories/pattern/atom.xml" rel="self"/>
  <link href="http://go.aopphp.com/"/>
  <updated>2013-06-22T13:16:44+04:00</updated>
  <id>http://go.aopphp.com/</id>
  <author>
    <name><![CDATA[Lisachenko Alexander]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Implementing reusable fluent interface pattern in PHP with AOP]]></title>
    <link href="http://go.aopphp.com/blog/2013/03/19/implementing-fluent-interface-pattern-in-php/"/>
    <updated>2013-03-19T22:44:00+04:00</updated>
    <id>http://go.aopphp.com/blog/2013/03/19/implementing-fluent-interface-pattern-in-php</id>
    <content type="html"><![CDATA[<p>During software development one of the most important goals is the readability of source code. There are special
techniques and tips that help us to improve the readability of source code. One of the techniques of improving the
source code readability is using of fluent interfaces. Let&rsquo;s discuss it in this article.</p>

<!-- more -->


<h3>Evolution. From simple to complex.</h3>

<p>Every programmer starts with the language by writing a trivial &ldquo;Hello, world!&rdquo;. After that, it takes several years to
learn the language and to make clumsy attempts to write his own ORM / CMS / Framework (underline one or several). I
think that everyone has the code which is better to hide. But without understanding of simple things you will not be
able to understand the complex ones, so let&rsquo;s start with a simple example and get to the implementation of the &ldquo;fluent&rdquo;
interface as a separate class using AOP. Those who know this pattern can safely move on to the last part of the article,
where you can get excellent food for thoughts.</p>

<p>Let&rsquo;s start!</p>

<p>Let&rsquo;s take a simple user entity, which has the following properties: name, last name and the password:</p>

<p><code>php
&lt;?php
class User
{
    public $name;
    public $surname;
    public $password;
}
</code>
An excellent class that is easy to use:
```php
&lt;?php
$user = new User;</p>

<p>$user->name = &lsquo;John&rsquo;;
$user->surname = &lsquo;Doe&rsquo;;
$user->password = &lsquo;root&rsquo;;
```</p>

<p>It is easy to notice that we have no validation and somebody can set a blank password, which is not very good. In
addition, it would be nice to know that the field values are immutable. These several considerations lead us to the
idea that properties should be protected or private and access to them should be carried out with a pair of getter / setter.</p>

<p>Suit the action to the word:
```php
&lt;?php
class User
{</p>

<pre><code>protected $name;
protected $surname;
protected $password;

public function setName($name)
{
    $this-&gt;name = $name;
}

public function setSurname($surname)
{
    $this-&gt;surname = $surname;
}

public function setPassword($password)
{
    if (!$password) {
        throw new InvalidArgumentException("Password shouldn't be empty");
    }
    $this-&gt;password = $password;
}
</code></pre>

<p>}
<code>
For the new class the configuration has changed a little and now we are using setters:
</code>php
&lt;?php
$user = new User;</p>

<p>$user->setName(&lsquo;John&rsquo;);
$user->setSurname(&lsquo;Doe&rsquo;);
$user->setPassword(&lsquo;root&rsquo;);
```</p>

<p>Not a big deal, right? But what if we need to set up 20 properties? 30 properties? This code will be flooded with setter
calls and $user variable references. If the variable name will be $superImportantUser then readability of the source
code deteriorates further. What can be done to get rid of the copy of the code?</p>

<h3>Fluent interface to the rescue!</h3>

<p>So, we came to the Fluent Interface pattern, which was coined by Eric Evans and Martin Fowler to increase readability of
source code by simplifying multiple calls to the same object. It is implemented by a chain of methods, transmitting the
calling context to the following method in the chain. The context is the return value of the method and this value can
be any object, including the current one.</p>

<p>To implement a fluent interface, we need all the methods-setters to return the current object:
```php
&lt;?php
class User
{</p>

<pre><code>protected $name;
protected $surname;
protected $password;

public function setName($name)
{
    $this-&gt;name = $name;
    return $this;
}

public function setSurname($surname)
{
    $this-&gt;surname = $surname;
    return $this;
}

public function setPassword($password)
{
    if (!$password) {
        throw new InvalidArgumentException("Password shouldn't be empty");
    }
    $this-&gt;password = $password;
    return $this;
}
</code></pre>

<p>}
```
This approach will allow us to make the call chain:</p>

<p><code>php
&lt;?php
$user = new User;
$user-&gt;setName('John')-&gt;setSurname('Doe')-&gt;setPassword('root');
</code></p>

<p>As you can see, the configuration of the object now takes up less space and is much easier to read. We achieved our
goal! At this point, many developers will ask: &ldquo;So what?&rdquo; Ok, then try to answer the question: &ldquo;What&rsquo;s wrong with fluent
interface in this way?&rdquo; before reading the next section.</p>

<h3>So what&rsquo;s bad in it?</h3>

<p>Perhaps you&rsquo;ve failed to find an answer and you&rsquo;ve decided to read further? ) Well, I can reassure you that it&rsquo;s all
fine with fluent interface in OOP. However, if you think about it, you can find out that it can&rsquo;t be implemented as a
separate class, interface or trait. So it can&rsquo;t be reused. This results in the fact that we have to put down &ldquo;return
$this&rdquo; at the end of each method to implement fluent interface. If we have a couple dozen classes with a couple dozen
methods that we want to do &ldquo;fluent&rdquo; then we have to manually deal with this unpleasant operation.
This is the classic crosscutting.</p>

<h3>Let&rsquo;s make it in a separate class</h3>

<p>Since we have a crosscutting, we must rise to the level above OOP to describe this pattern. Specification is pretty
simple: when calling public methods in a class, original object should be returned as the result of the method
invocation. Of course, we do not want unexpected effects, so let&rsquo;s be clear: methods should be public setters starting
with &ldquo;set&rdquo; and they should be inside classes that implement FluentInterface marker only . Let&rsquo;s describe this with AOP
and Go! AOP library.</p>

<p>First of all, our marker interface:</p>

<p>```php
&lt;?php
/<em>*
 * Fluent interface marker
 </em>/
interface FluentInterface
{</p>

<p>}
```
Fluent interface implementation in the form of advice within aspect:</p>

<p>```php
&lt;?php
use Go\Aop\Aspect;
use Go\Aop\Intercept\MethodInvocation;
use Go\Lang\Annotation\Around;</p>

<p>class FluentInterfaceAspect implements Aspect
{</p>

<pre><code>/**
 * Fluent interface advice
 *
 * @Around("within(FluentInterface+) &amp;&amp; execution(public **-&gt;set*(*))")
 *
 * @param MethodInvocation $invocation
 * @return mixed|null|object
 */
protected function aroundMethodExecution(MethodInvocation $invocation)
{
    $result = $invocation-&gt;proceed();
    return $result!==null ? $result : $invocation-&gt;getThis();
}
</code></pre>

<p>}
```</p>

<p>Just a quick explanation &ndash; &ldquo;Around&rdquo; advice sets the hook &ldquo;around&rdquo; the original method and is fully responsible for
whether the original method will be called or not, and is responsible for the result that will be returned. In the
advice, we call original method (setter invocation) and if it doesn&rsquo;t return anything we just return the original
object $invocation->getThis(). That is all ) That is a useful pattern implementation just in a few lines of code. Using
the fluent interface is now easy and sexy :)</p>

<p>```php
&lt;?php
class User implements FluentInterface
{</p>

<pre><code>protected $name;
protected $surname;
protected $password;

public function setName($name)
{
    $this-&gt;name = $name;
}

public function setSurname($surname)
{
    $this-&gt;surname = $surname;
}

public function setPassword($password)
{
    if (!$password) {
        throw new InvalidArgumentException("Password shouldn't be empty");
    }
    $this-&gt;password = $password;
}
</code></pre>

<p>}
```
And usage:</p>

<p><code>php
&lt;?php
$user = new User;
$user-&gt;setName('John')-&gt;setSurname('Doe')-&gt;setPassword('root');
</code>
No more copying &ldquo;return $this&rdquo; for hundreds of methods, only pure source code, intuitive FluentInterface and
implementation of FluentInterface in the form of a simple aspect.</p>
]]></content>
  </entry>
  
</feed>
